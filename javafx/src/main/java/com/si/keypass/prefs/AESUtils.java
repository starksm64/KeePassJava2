package com.si.keypass.prefs;


import java.math.BigInteger;
import java.security.KeyStore;
import java.security.MessageDigest;
import java.security.interfaces.RSAPrivateCrtKey;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * Utility class for AES encryption/decryption using an RSA private key from a keystore certificate.
 * An example keystore could be created via this keytool command:
 *  keytool -genkey -alias oanda -keyalg RSA -keysize 4096 -dname CN=keys.starkinternational.com -validity 3652 \
 *  -keystore keys.jks -storepass keyprotection
 *
 *  Information about RSA keys:
 *  https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Operation
 *
 * https://tools.ietf.org/html/rfc8017#appendix-A.1.1:
 An RSA private key should be represented with the ASN.1 type RSAPrivateKey:

 RSAPrivateKey ::= SEQUENCE {
 version           Version,
 modulus           INTEGER,  -- n
 publicExponent    INTEGER,  -- e
 privateExponent   INTEGER,  -- d
 prime1            INTEGER,  -- p
 prime2            INTEGER,  -- q
 exponent1         INTEGER,  -- d mod (p-1)
 exponent2         INTEGER,  -- d mod (q-1)
 coefficient       INTEGER,  -- (inverse of q) mod p
 otherPrimeInfos   OtherPrimeInfos OPTIONAL
 }

 The fields of type RSAPrivateKey have the following meanings:

 o  version is the version number, for compatibility with future
 revisions of this document.  It SHALL be 0 for this version of the
 document, unless multi-prime is used; in which case, it SHALL be
 1.

 Version ::= INTEGER { two-prime(0), multi(1) }
 (CONSTRAINED BY
 {-- version must be multi if otherPrimeInfos present --})

 o  modulus is the RSA modulus n.

 o  publicExponent is the RSA public exponent e.

 o  privateExponent is the RSA private exponent d.

 o  prime1 is the prime factor p of n.

 o  prime2 is the prime factor q of n.

 o  exponent1 is d mod (p - 1).

 o  exponent2 is d mod (q - 1).

 o  coefficient is the CRT coefficient q^(-1) mod p.
 */
public class AESUtils {
    /**
     * Encrypt the given plain text using the RSA private key from the key store as named by the
     * alias. This generates a 256 bit AES secret key by hashing the encoded form of the
     * RSA private key using a SHA-256 message digest, and the AES IV is taken from the
     * getPrivateExponent hashes using SHA-256 message digest and only the first 128 bits used.
     *
     * @param keyStore - a KeyStore instance as generated by the keytool utility
     * @param keyAlias - alias to a key entry in keyStore for the private key and associated certificate chain for public key
     * @param keyPassword - the password associated with the key
     * @param plainText - the text to encrypt
     * @return - the base64 encoded crypto text
     * @throws Exception - on any JCE failure
     *
     * @see RSAPrivateCrtKey
     */
    public static String encryptText(KeyStore keyStore, String keyAlias, char[] keyPassword, String plainText) throws Exception {
        RSAPrivateCrtKey privateCrtKey = (RSAPrivateCrtKey) keyStore.getKey(keyAlias, keyPassword);
        byte[] encoded = privateCrtKey.getEncoded();

        //create AES key
        MessageDigest md256 = MessageDigest.getInstance("SHA-256");
        byte[] key = md256.digest(encoded);
        SecretKey secretKey = new SecretKeySpec(key, "AES");

        //create AES IV
        BigInteger coefficient = privateCrtKey.getPrivateExponent();
        byte[] iv256 = md256.digest(coefficient.toByteArray());
        byte[] iv128 = new byte[128/8];
        System.arraycopy(iv256, 0, iv128, 0, iv128.length);
        IvParameterSpec ivspec = new IvParameterSpec(iv128);

        //define cipher mode
        Cipher cipher = Cipher.getInstance("AES/CTR/NOPADDING");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivspec);

        //encode
        byte[] result = cipher.doFinal(plainText.getBytes());

        //print out the encrypted text
        String base64 = Base64.getEncoder().encodeToString(result);
        return base64;
    }

    /**
     *
     * Decrypt the given crypto text using the RSA private key from the key store as named by the
     * alias.
     *
     * @param keyStore - a KeyStore instance as generated by the keytool utility
     * @param keyAlias - alias to a key entry in keyStore for the private key and associated certificate chain for public key
     * @param keyPassword - the password associated with the key
     * @param base64CipherText - a base64 encoding of the crypto text
     * @return - the decrypted plain text
     * @throws Exception - on any JCE failure
     *
     * @see RSAPrivateCrtKey
     * @see #encryptText(KeyStore, String, char[], String)
     */
    public static String decryptText(KeyStore keyStore, String keyAlias, char[] keyPassword, String base64CipherText) throws Exception {
        RSAPrivateCrtKey privateCrtKey = (RSAPrivateCrtKey) keyStore.getKey(keyAlias, keyPassword);
        byte[] encoded = privateCrtKey.getEncoded();

        //create AES key
        MessageDigest md256 = MessageDigest.getInstance("SHA-256");
        byte[] key = md256.digest(encoded);
        SecretKey secretKey = new SecretKeySpec(key, "AES");

        //create AES IV
        BigInteger coefficient = privateCrtKey.getPrivateExponent();
        byte[] iv256 = md256.digest(coefficient.toByteArray());
        byte[] iv128 = new byte[128/8];
        System.arraycopy(iv256, 0, iv128, 0, iv128.length);
        IvParameterSpec ivspec = new IvParameterSpec(iv128);

        //define cipher mode
        Cipher cipher = Cipher.getInstance("AES/CTR/NOPADDING");
        cipher.init(Cipher.DECRYPT_MODE, secretKey, ivspec);

        //decode
        byte[] cipherText = Base64.getDecoder().decode(base64CipherText.getBytes());
        byte[] result = cipher.doFinal(cipherText);
        return new String(result, "UTF-8");
    }

}